As we've already analyzed the specifications and the loops, it's time to try to analyze what invariants and patterns hold during the execution of the program. Go over the found loops in the following program in the code and try to find out what invariants and patterns they hold. Go through all your thinking and reasoning process step by step.
```
from typing import cast, List, Dict, Set, Optional, Union
from nagini_contracts.contracts import *

@Pure
def Sum(a : List[int], s : int, t : int) -> int :
    Requires(Acc(list_pred(a)))
    Requires(((0) <= (s)) and ((s) <= (t)) and ((t) <= (len(a))))

    if s == t:
        return 0
    else:
        return (a)[t - 1] + (Sum(a, s, t - 1))

def sum_loop(numbers: List[int]) -> int:
    Requires(Acc(list_pred(numbers)))
    Ensures(Acc(list_pred(numbers)))
    Ensures(Result() == Sum(numbers, 0, len(numbers)))
    s = int(0)
    i = int(0)
    while (i) < (len(numbers)):
        s = s + (numbers)[i]
        i = i + 1
    return s
```